/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.15.4.0 (NJsonSchema v9.10.29.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';
import { HttpObserve } from '@angular/common/http/src/client';
import { AuthOptions, DA_OPTIONS_TOKEN } from '@delon/auth';

export class AbpResult<T> {
    success: boolean;
    error: string;
    result: T;
    targetUrl: string;
    unAuthorizedRequest: boolean;
}

@Injectable()
export class AccountClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput): Observable<AbpResult<IsTenantAvailableOutput>> {
        let url_ = '/api/services/app/Account/IsTenantAvailable';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    register(input: RegisterInput): Observable<AbpResult<RegisterOutput>> {
        let url_ = '/api/services/app/Account/Register';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class ConfigurationClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Configuration/ChangeUiTheme';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class ProductServiceClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    get(id: number): Observable<AbpResult<ProductSummaryDto>> {
        let url_ = '/api/services/ProductDemo/ProductService/Get?';
        if (id === undefined || id === null)
            throw new Error('The parameter "id" must be defined and cannot be null.');
        else
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @name (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getAll(name: string, sorting: string, skipCount: number, maxResultCount: number): Observable<AbpResult<PagedResultDtoOfProductSummaryDto>> {
        let url_ = '/api/services/ProductDemo/ProductService/GetAll?';
        if (name !== undefined)
            url_ += 'Name=' + encodeURIComponent('' + name) + '&'; 
        if (sorting !== undefined)
            url_ += 'Sorting=' + encodeURIComponent('' + sorting) + '&'; 
        if (skipCount === undefined || skipCount === null)
            throw new Error('The parameter "skipCount" must be defined and cannot be null.');
        else
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error('The parameter "maxResultCount" must be defined and cannot be null.');
        else
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: ProductCreateDto): Observable<AbpResult<ProductSummaryDto>> {
        let url_ = '/api/services/ProductDemo/ProductService/Create';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: ProductCreateDto): Observable<AbpResult<ProductSummaryDto>> {
        let url_ = '/api/services/ProductDemo/ProductService/Update';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/ProductDemo/ProductService/Delete?';
        if (id === undefined || id === null)
            throw new Error('The parameter "id" must be defined and cannot be null.');
        else
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }
}

@Injectable()
export class RoleClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto): Observable<AbpResult<RoleDto>> {
        let url_ = '/api/services/app/Role/Create';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: RoleDto): Observable<AbpResult<RoleDto>> {
        let url_ = '/api/services/app/Role/Update';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Role/Delete?';
        if (id === undefined || id === null)
            throw new Error('The parameter "id" must be defined and cannot be null.');
        else
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<AbpResult<ListResultDtoOfPermissionDto>> {
        let url_ = '/api/services/app/Role/GetAllPermissions';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<AbpResult<RoleDto>> {
        let url_ = '/api/services/app/Role/Get?';
        if (id === undefined || id === null)
            throw new Error('The parameter "id" must be defined and cannot be null.');
        else
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    getAll(skipCount: number, maxResultCount: number): Observable<AbpResult<PagedResultDtoOfRoleDto>> {
        let url_ = '/api/services/app/Role/GetAll?';
        if (skipCount === undefined || skipCount === null)
            throw new Error('The parameter "skipCount" must be defined and cannot be null.');
        else
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error('The parameter "maxResultCount" must be defined and cannot be null.');
        else
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class SessionClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<AbpResult<GetCurrentLoginInformationsOutput>> {
        let url_ = '/api/services/app/Session/GetCurrentLoginInformations';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

@Injectable()
export class TenantClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateTenantDto): Observable<AbpResult<TenantDto>> {
        let url_ = '/api/services/app/Tenant/Create';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/Tenant/Delete?';
        if (id === undefined || id === null)
            throw new Error('The parameter "id" must be defined and cannot be null.');
        else
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<AbpResult<TenantDto>> {
        let url_ = '/api/services/app/Tenant/Get?';
        if (id === undefined || id === null)
            throw new Error('The parameter "id" must be defined and cannot be null.');
        else
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    getAll(skipCount: number, maxResultCount: number): Observable<AbpResult<PagedResultDtoOfTenantDto>> {
        let url_ = '/api/services/app/Tenant/GetAll?';
        if (skipCount === undefined || skipCount === null)
            throw new Error('The parameter "skipCount" must be defined and cannot be null.');
        else
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error('The parameter "maxResultCount" must be defined and cannot be null.');
        else
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: TenantDto): Observable<AbpResult<TenantDto>> {
        let url_ = '/api/services/app/Tenant/Update';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }
}

@Injectable()
export class TokenAuthClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * 获取WebApi访问令牌（token）
     * @model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel): Observable<AbpResult<AuthenticateResultModel>> {
        let url_ = '/api/TokenAuth/Authenticate';

        const content_ = model;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<AbpResult<ExternalLoginProviderInfoModel[]>> {
        let url_ = '/api/TokenAuth/GetExternalAuthenticationProviders';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel): Observable<AbpResult<ExternalAuthenticateResultModel>> {
        let url_ = '/api/TokenAuth/ExternalAuthenticate';

        const content_ = model;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }
}

@Injectable()
export class UserClient {
    private http: HttpClient;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DA_OPTIONS_TOKEN) private authOptions?: AuthOptions) {
        this.http = http;
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateUserDto): Observable<AbpResult<UserDto>> {
        let url_ = '/api/services/app/User/Create';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: UserDto): Observable<AbpResult<UserDto>> {
        let url_ = '/api/services/app/User/Update';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('put', url_, options_);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/User/Delete?';
        if (id === undefined || id === null)
            throw new Error('The parameter "id" must be defined and cannot be null.');
        else
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('delete', url_, options_);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<AbpResult<ListResultDtoOfRoleDto>> {
        let url_ = '/api/services/app/User/GetRoles';

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto): Observable<AbpResult<void>> {
        let url_ = '/api/services/app/User/ChangeLanguage';

        const content_ = input;

        let options_ = {
            body: content_ as any,
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('post', url_, options_);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<AbpResult<UserDto>> {
        let url_ = '/api/services/app/User/Get?';
        if (id === undefined || id === null)
            throw new Error('The parameter "id" must be defined and cannot be null.');
        else
            url_ += 'Id=' + encodeURIComponent('' + id) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }

    /**
     * @return Success
     */
    getAll(skipCount: number, maxResultCount: number): Observable<AbpResult<PagedResultDtoOfUserDto>> {
        let url_ = '/api/services/app/User/GetAll?';
        if (skipCount === undefined || skipCount === null)
            throw new Error('The parameter "skipCount" must be defined and cannot be null.');
        else
            url_ += 'SkipCount=' + encodeURIComponent('' + skipCount) + '&'; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error('The parameter "maxResultCount" must be defined and cannot be null.');
        else
            url_ += 'MaxResultCount=' + encodeURIComponent('' + maxResultCount) + '&'; 
        
        url_ = url_.replace(/[?&]$/, '');

        let options_ = {
            observe: 'body' as HttpObserve,
            responseType: 'json' as any,
            headers: new HttpHeaders({
                'Content-Type': 'application/json', 
                'Accept': 'application/json'
            }),
            params: new HttpParams().set(this.authOptions.allow_anonymous_key, '1'),
            reportProgress: false,
            withCredentials: false
        };
        return this.http.request('get', url_, options_);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state?: IsTenantAvailableOutputState;
    tenantId?: number;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state?: IsTenantAvailableOutputState;
    tenantId?: number;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse?: string;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse?: string;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin?: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin?: boolean;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ProductSummaryDto implements IProductSummaryDto {
    name?: string;
    creationTime?: Date;
    creatorUserId?: number;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    isDeleted?: boolean;
    deletionTime?: Date;
    deleterUserId?: number;
    id?: number;

    constructor(data?: IProductSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.isDeleted = data["isDeleted"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.deleterUserId = data["deleterUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProductSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["deleterUserId"] = this.deleterUserId;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProductSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IProductSummaryDto {
    name?: string;
    creationTime?: Date;
    creatorUserId?: number;
    lastModificationTime?: Date;
    lastModifierUserId?: number;
    isDeleted?: boolean;
    deletionTime?: Date;
    deleterUserId?: number;
    id?: number;
}

export class PagedResultDtoOfProductSummaryDto implements IPagedResultDtoOfProductSummaryDto {
    totalCount?: number;
    items?: ProductSummaryDto[];

    constructor(data?: IPagedResultDtoOfProductSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ProductSummaryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfProductSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfProductSummaryDto {
    totalCount?: number;
    items?: ProductSummaryDto[];
}

export class ProductCreateDto implements IProductCreateDto {
    name?: string;
    id?: number;

    constructor(data?: IProductCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ProductCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProductCreateDto();
        result.init(json);
        return result;
    }
}

export interface IProductCreateDto {
    name?: string;
    id?: number;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName?: string;
    description?: string;
    isStatic?: boolean;
    permissions?: string[];

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName?: string;
    description?: string;
    isStatic?: boolean;
    permissions?: string[];
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName?: string;
    description?: string;
    isStatic?: boolean;
    permissions?: string[];
    id?: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName?: string;
    description?: string;
    isStatic?: boolean;
    permissions?: string[];
    id?: number;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items?: PermissionDto[];

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items?: PermissionDto[];
}

export class PermissionDto implements IPermissionDto {
    name?: string;
    displayName?: string;
    description?: string;
    id?: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name?: string;
    displayName?: string;
    description?: string;
    id?: number;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount?: number;
    items?: RoleDto[];

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount?: number;
    items?: RoleDto[];
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application?: ApplicationInfoDto;
    user?: UserLoginInfoDto;
    tenant?: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application?: ApplicationInfoDto;
    user?: UserLoginInfoDto;
    tenant?: TenantLoginInfoDto;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version?: string;
    releaseDate?: Date;
    features?: { [key: string] : boolean; };

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? new Date(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version?: string;
    releaseDate?: Date;
    features?: { [key: string] : boolean; };
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name?: string;
    surname?: string;
    userName?: string;
    emailAddress?: string;
    id?: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name?: string;
    surname?: string;
    userName?: string;
    emailAddress?: string;
    id?: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName?: string;
    name?: string;
    id?: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName?: string;
    name?: string;
    id?: number;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString?: string;
    isActive?: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString?: string;
    isActive?: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive?: boolean;
    id?: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive?: boolean;
    id?: number;
}

export class PagedResultDtoOfTenantDto implements IPagedResultDtoOfTenantDto {
    totalCount?: number;
    items?: TenantDto[];

    constructor(data?: IPagedResultDtoOfTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantDto {
    totalCount?: number;
    items?: TenantDto[];
}

export class AuthenticateModel implements IAuthenticateModel {
    /** 用户名或者绑定的Email */
    userNameOrEmailAddress: string;
    /** 登录密码 */
    password: string;
    /** 是否保持登录 */
    rememberClient?: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    /** 用户名或者绑定的Email */
    userNameOrEmailAddress: string;
    /** 登录密码 */
    password: string;
    /** 是否保持登录 */
    rememberClient?: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
    userId?: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
    userId?: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name?: string;
    clientId?: string;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name?: string;
    clientId?: string;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
    waitingForActivation?: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken?: string;
    encryptedAccessToken?: string;
    expireInSeconds?: number;
    waitingForActivation?: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive?: boolean;
    roleNames?: string[];
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive?: boolean;
    roleNames?: string[];
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive?: boolean;
    fullName?: string;
    lastLoginTime?: Date;
    creationTime?: Date;
    roleNames?: string[];
    id?: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? new Date(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive?: boolean;
    fullName?: string;
    lastLoginTime?: Date;
    creationTime?: Date;
    roleNames?: string[];
    id?: number;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items?: RoleDto[];

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items?: RoleDto[];
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount?: number;
    items?: UserDto[];

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount?: number;
    items?: UserDto[];
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}